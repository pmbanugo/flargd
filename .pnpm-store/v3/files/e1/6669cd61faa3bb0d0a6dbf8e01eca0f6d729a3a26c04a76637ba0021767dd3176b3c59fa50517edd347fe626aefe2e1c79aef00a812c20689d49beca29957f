/**
 * @remix-run/cloudflare-workers v1.12.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import { getAssetFromKV, MethodNotAllowedError, NotFoundError } from '@cloudflare/kv-asset-handler';
import { createRequestHandler as createRequestHandler$1 } from '@remix-run/cloudflare';

// Needed because the @cloudflare/workers-types do not include the `process` global

/**
 * A function that returns the value to use as `context` in route `loader` and
 * `action` functions.
 *
 * You can think of this as an escape hatch that allows you to pass
 * environment/platform-specific values through to your loader/action.
 */

/**
 * Returns a request handler for the Cloudflare runtime that serves the
 * Remix SSR response.
 */
function createRequestHandler({
  build,
  getLoadContext,
  mode
}) {
  let handleRequest = createRequestHandler$1(build, mode);
  return event => {
    let loadContext = getLoadContext === null || getLoadContext === void 0 ? void 0 : getLoadContext(event);
    return handleRequest(event.request, loadContext);
  };
}
async function handleAsset(event, build, options) {
  try {
    if (process.env.NODE_ENV === "development") {
      return await getAssetFromKV(event, {
        cacheControl: {
          bypassCache: true
        },
        ...options
      });
    }
    let cacheControl = {};
    let url = new URL(event.request.url);
    let assetpath = build.assets.url.split("/").slice(0, -1).join("/");
    let requestpath = url.pathname.split("/").slice(0, -1).join("/");
    if (requestpath.startsWith(assetpath)) {
      // Assets are hashed by Remix so are safe to cache in the browser
      // And they're also hashed in KV storage, so are safe to cache on the edge
      cacheControl = {
        bypassCache: false,
        edgeTTL: 31536000,
        browserTTL: 31536000
      };
    } else {
      // Assets are not necessarily hashed in the request URL, so we cannot cache in the browser
      // But they are hashed in KV storage, so we can cache on the edge
      cacheControl = {
        bypassCache: false,
        edgeTTL: 31536000
      };
    }
    return await getAssetFromKV(event, {
      cacheControl,
      ...options
    });
  } catch (error) {
    if (error instanceof MethodNotAllowedError || error instanceof NotFoundError) {
      return null;
    }
    throw error;
  }
}
function createEventHandler({
  build,
  getLoadContext,
  mode
}) {
  let handleRequest = createRequestHandler({
    build,
    getLoadContext,
    mode
  });
  let handleEvent = async event => {
    let response = await handleAsset(event, build);
    if (!response) {
      response = await handleRequest(event);
    }
    return response;
  };
  return event => {
    try {
      event.respondWith(handleEvent(event));
    } catch (e) {
      if (process.env.NODE_ENV === "development") {
        event.respondWith(new Response(e.message || e.toString(), {
          status: 500
        }));
        return;
      }
      event.respondWith(new Response("Internal Error", {
        status: 500
      }));
    }
  };
}

export { createEventHandler, createRequestHandler, handleAsset };
